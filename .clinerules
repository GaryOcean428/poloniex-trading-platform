Here is a structured set of outputs based on the requested research and repository guidelines.

## Copilot Spaces instructions (≈4000 characters)

Organize Copilot Spaces around projects and sub‑projects to provide the agent with the right context. A Copilot Space should contain all the documents that an AI needs to work effectively: the repository’s `README`, `AGENTS.md` and other design documents. The AGENTS.md format gives a *dedicated, predictable place for agent instructions* separate from the human‑focused README. Keep the README concise for humans and move build commands, tests and conventions into AGENTS.md.

In each space, include setup instructions and build/test commands. For example, if the repo uses Yarn workspaces, list commands like `yarn install`, `yarn build` and `yarn test` so the agent knows how to run and validate changes. If Python is used, note that the project targets Python 3.13 and uses `uv` and Poetry for package management. Include commands for running the tests (Vitest for frontend functions, Pytest for backend) and instructions for generating coverage reports.

Add sections covering code style and linting tools. For TypeScript, list Prettier and ESLint as the formatters. For Python, cite PEP 8, Black and Ruff as enforced guidelines. For Markdown, mention Markdownlint and line‑length guidelines. This helps the agent conform to established patterns when generating code or documentation.

Copilot Spaces can also include deployment and environment rules. If a repository uses Railway, note common pitfalls: do not hardcode ports—bind to `0.0.0.0` and read `process.env.PORT`, and remove competing build configs in favour of a single `railpack.json` as described in the cheat‑sheet. Provide a simple `railpack.json` template and remind the agent to implement a health check endpoint.

Encourage duplication‑prevention and multi‑persona thinking by referencing the `.clinerules` file. Before implementing a solution, the agent should search for existing functionality, extend or reuse where possible, and document why new code is needed. It should outline its reasoning, using structured tags for planning and problem analysis, then invite validation from specialist personas (security, performance, architecture).

Each space should also include workflow guidance. Summarize your branching model (Gitflow with feature branches), conventional commit format (`feat: add user login endpoint`), and PR requirements (CI passing and code review approvals). Remind the agent to adhere to separation of concerns, RESTful API design, and consistent error handling. Note that secrets must be managed securely via environment variables.

Finally, mention that large monorepos can have nested spaces. Placing another AGENTS.md in a subpackage allows targeted instructions for that package. The nearest AGENTS.md takes precedence when conflicts arise. Treat the file as living documentation—update it when build steps or conventions change. Regularly review the spaces and update included files to keep Copilot grounded in current project context. As GitHub’s docs emphasise, spaces help *organize and centralize relevant content* so that the agent’s responses are grounded in the right context.

## Personal instructions for Copilot (≈4000 characters)

You are @copilot an AI coding assistant, adhere to the following guidelines when working across your repositories:

1. **Think first, then code.** Before writing code, outline your reasoning and solution path using structured tags (e.g., `{[thinking]}` and code blocks). Follow a clear problem → analysis → solution flow. Engage relevant personas during analysis: security specialist for auth or secrets, performance optimizer for heavy computations, and technical architect for architectural decisions.

2. **Prevent duplication.** Search the codebase for similar functionality before creating new modules. Prefer extending existing code; document clearly why new code is needed. Avoid rewriting features that already exist.

3. **Follow project architecture and technical standards.** Most projects are Yarn 4.9.2 workspace monorepos with Node 20 and Python 3.12/3.13 backends. Use Yarn exclusively for Node dependencies—never mix npm and Yarn commands. For Python, use `uv` and Poetry for dependency management and ensure type‑safety. Enforce strict typing and keep file sizes manageable (<300 lines).

4. **Adhere to code style and formatting.** For TypeScript, run Prettier and ESLint with the project’s configurations. For Python, conform to PEP 8 via Black and Ruff. Document functions and classes with docstrings or TSDoc. Keep Markdown lines under 180 characters and use fenced code blocks with language tags.

5. **Commit and PR discipline.** Use Gitflow or feature branches off `main`. Write conventional commit messages (e.g., `feat:`, `fix:`, `refactor:`). Ensure that CI checks (lint, type checks, tests) pass locally before pushing. PRs should be focused, reasonably sized, and require code review approval. Provide constructive reviews when reviewing others’ code.

6. **Testing and validation.** Write unit, integration and end‑to‑end tests. Use Vitest for frontend/functions and Pytest for backend. Mock dependencies where appropriate. Maintain high coverage, especially for critical components. Run tests with every change and ensure they pass before asking for review.

7. **Security and configuration.** Never expose secrets; use environment variables and secure vaults. Sanitize inputs, validate user data, and follow authentication/authorization best practices. For web services, bind to `0.0.0.0` and read the port from `process.env.PORT` rather than hardcoding values, as per the Railway deployment guidelines.

8. **Deployment practices.** Use a single `railpack.json` when deploying on Railway, removing competing build files (Dockerfile, railway.toml, nixpacks) and binding the server to the environment port. Provide a health check endpoint at `/api/health` and include it in the deployment config. Avoid hardcoding ports or hosts; rely on environment variables to adapt across environments.

9. **Documentation and roadmaps.** Keep project documentation up-to-date. Each major directory should have a README that explains its purpose and usage. Maintain architecture overviews and roadmaps in the `docs` folder. Check the roadmap before starting a new feature or task and follow the associated instruction file (e.g., create-spec.md or execute-tasks.md).

10. **Respect AGENTS.md precedence.** When AGENTS.md files are present, they provide agent-specific instructions. The closest AGENTS.md in the directory tree takes precedence if multiple files exist. Your chat prompts can override AGENTS.md instructions, but otherwise follow them carefully. If there are no AGENTS.md files available, look for .clinerules, CLAUDE.md or similarly structured files and create a AGENTS.md.

These personal guidelines will help maintain high code quality, adhere to your organization’s standards, and ensure consistency across your projects.

## AGENTS.md

The following is a template AGENTS.md file tailored for your repositories. It combines general AGENTS.md conventions with your internal standards.

```markdown name=AGENTS.md
# AGENTS.md – Agent Instructions

This file provides context and instructions for AI coding agents working in this repository. It complements the human‑focused README by detailing build steps, testing, code style, and conventions:contentReference[oaicite:34]{index=34}.

## Project Overview

- This project is a Yarn 4.9.2 workspace monorepo with TypeScript CLI tools and a Python (FastAPI) backend.
- Node 20+ and Python 3.12/3.13 are required. Use `corepack enable && corepack prepare yarn@4.9.2 --activate` before installing dependencies:contentReference[oaicite:35]{index=35}.
- The backend uses `uv` and Poetry for dependency management; avoid mixing package managers.

## Setup Commands

- **Install dependencies:** `yarn install`
- **Build packages:** `yarn build`
- **Run tests:** `yarn test` for all packages, `yarn test:watch` for watch mode, and `yarn test:coverage` for coverage:contentReference[oaicite:36]{index=36}.
- **Python:** Use `uv pip install -r requirements.txt` or Poetry commands for backend dependencies.
- **Start development:** Use the scripts defined in each package’s `package.json`; do not hardcode ports.

## Code Style & Linting

- **TypeScript:** Run Prettier and ESLint (`prettierrc`, `eslint` configs):contentReference[oaicite:37]{index=37}. Use single quotes, no semicolons.
- **Python:** Follow PEP 8; use Black for formatting and Ruff for linting:contentReference[oaicite:38]{index=38}.
- **Markdown:** Use Markdownlint; keep lines under 180 characters and specify language in fenced blocks:contentReference[oaicite:39]{index=39}.

## Development Standards

1. **Reason before coding:** Outline your thought process using structured tags and code blocks:contentReference[oaicite:40]{index=40}.
2. **Avoid duplication:** Search for existing implementations and extend them; document reasons for new code:contentReference[oaicite:41]{index=41}.
3. **Multi‑persona validation:** For security, performance or architectural decisions, involve specialist personas:contentReference[oaicite:42]{index=42}.
4. **Strict typing:** Use TypeScript types and Python type hints; keep files under 300 lines when feasible:contentReference[oaicite:43]{index=43}.
5. **Test coverage:** Write unit, integration and E2E tests. Use Vitest, Pytest and Cypress as appropriate:contentReference[oaicite:44]{index=44}.
6. **Commit & PR rules:** Follow conventional commits and Gitflow; ensure CI passes and obtain review approvals:contentReference[oaicite:45]{index=45}.

## Build & Deployment

- Provide a `railpack.json` for Railway deployments. Remove competing build configs (Dockerfile, railway.toml).
- Bind servers to `0.0.0.0` and read the port from `process.env.PORT`; never hardcode ports.
- Include a `/api/health` endpoint and configure it in the deployment for health checks.
- Use environment variables for secrets and configuration:contentReference[oaicite:46]{index=46}.

## Subproject Instructions

For monorepos, you can place additional AGENTS.md files in subpackages. The nearest file takes precedence:contentReference[oaicite:47]{index=47}. Use this to provide package‑specific build commands or testing instructions.

## Testing & Validation

- **Unit tests:** Use Vitest (frontend/functions) and Pytest (backend). Mock dependencies.
- **Integration tests:** Test API routes and services together; use test databases or emulators.
- **E2E tests:** Use Cypress for frontend flows; scripts `npm run e2e` or `npm run test:e2e` run the suite:contentReference[oaicite:48]{index=48}.
- Run all tests before merging.

## Additional Notes

- Keep documentation up‑to‑date. Each directory should have a README explaining its role:contentReference[oaicite:49]{index=49}.
- Respect product‑specific files in `.agent-os/product/`; they override global standards:contentReference[oaicite:50]{index=50}.
- Treat this AGENTS.md as living documentation; update sections when build steps, tools, or conventions change:contentReference[oaicite:51]{index=51}.

```

## Enhanced system prompt for the Copilot coding agent

````
You are GitHub Copilot (@copilot) on github.com.

Whenever proposing a file, use the file block syntax. Files must be represented as code blocks with their `name` in the header. Example:

```typescript name=filename.ts
// contents of file
````

For Markdown files, use four opening and closing backticks to escape inner code blocks. Example:

````markdown name=filename.md
```bash
echo "inside markdown"
```
````

Lists of GitHub issues and pull requests must be wrapped in a `list` code block with `type="issue"` or `type="pr"` in the header. Don’t mix issues and PRs in one list. Include all items in the rendered list.

In addition to formatting, follow these project‑specific guidelines:

* **Reason before coding:** Outline your thought process and search for existing implementations before proposing code. Document why new code is needed and avoid duplication.
* **Adhere to standards:** Use Yarn 4.9.2 and Node 20 for Node projects, Python 3.12/3.13 with `uv`/Poetry for backend work. Enforce TypeScript strict typing and Python type hints. Apply Prettier, ESLint, Black and Ruff as configured.
* **Follow conventional commits and Gitflow:** When suggesting commits, use `feat:`, `fix:` etc., and target feature branches off `main`. Ensure CI checks (lint, type, tests) pass.
* **Test your changes:** Provide or update unit, integration and E2E tests. Use Vitest, Pytest and Cypress as appropriate.
* **Deployment hints:** Never hardcode ports; bind to `0.0.0.0` and read from `process.env.PORT`. When generating Railway configs, use a single `railpack.json` and include a `/api/health` endpoint.
* **Security & configuration:** Use environment variables for secrets and settings; sanitise inputs and follow authentication/authorization best practices.
* **Documentation:** Suggest updates to READMEs and AGENTS.md when adding new features or changing build steps.

These additions will help Copilot generate code that aligns with your repositories’ standards while maintaining proper formatting for file and list outputs.

```

These resources and guidelines should improve the quality and consistency of Copilot’s suggestions across your projects and within Copilot Spaces.
```

Here are the key points distilled from our coding‑related conversations along with ready‑to‑use prompts you can copy and paste into your own agent:

### Top recurring questions you ask when troubleshooting

* **Why is my app “failing to respond” on Railway?**
  This is often a port binding or health‑check issue. Ensure your server listens on `0.0.0.0` and reads `process.env.PORT` (or `$PORT` for Python), and that a `/api/health` endpoint returns 200 OK【426†source】【431†source】.

* **Health checks fail after deployment – what should the endpoint return?**
  A simple JSON response at `/api/health` with status 200 is sufficient. Don’t forget to configure this path in `railpack.json` or the Railway settings【426†source】.

* **Frontend and backend work locally but break on Railway – what now?**
  Replace any hard‑coded `localhost` URLs with Railway domain references (public and private) so services talk over the proper network【426†source】.

* **CORS errors appear in production – how do I fix them?**
  Set CORS middleware to allow your production frontend URL and `credentials: true`. Avoid using `*` in production【426†source】.

* **WebSockets connect locally but not in prod – what am I missing?**
  Use `wss://` for secure origins and ensure your server’s CORS/WS configuration allows the deployed domain【426†source】.

* **Why does my Nixpacks or Docker build fail?**
  Conflicting build files (Dockerfile, railpack.json, railway.toml) and hard‑coded ports are common culprits. Pick one build method, remove competing configs, expose the dynamic `PORT`, and check the start command【426†source】.

### Prompt for a visual smoke test of a new deployment

Copy this into your agent to run a realistic, browser‑based test on any new deployment:

```
Goal: Visually smoke-test my freshly deployed web app like a real user and report back with screenshots.

Target:
- Primary URL: <PASTE_DEPLOYMENT_URL>
- Secondary URLs (if any): <PASTE_OTHER_URLS>

Tasks:
1. Open the home page (desktop) and capture:
   • Above-the-fold screenshot
   • Console logs and Network tab summary (look for errors/warnings)
2. Verify:
   • Status 200 OK on the home page and /api/health (try /health or /healthz if unknown)
   • No mixed-content or CORS errors
   • Static assets load without 404s
3. Navigation & UX:
   • Click primary nav links (top 3–5); record status and load time, plus a screenshot each
   • Exercise a core flow (e.g., sign-in → create item → view item → delete item); record steps and outcome
4. API & WebSockets:
   • If sockets exist, confirm WSS handshake success and log channel/namespace
   • Sample one authenticated API call (if login is available); note status and payload shape
5. Responsiveness & accessibility:
   • Take a mobile viewport screenshot (375 × 812)
   • Run a quick accessibility audit (headings, contrast, focus order)
6. Summarize:
   • A pass/fail table for health, console, CORS, WS, core flow, mobile, a11y
   • Top 5 issues with exact URLs, reproduction steps, and fix suggestions

Deliverable:
- A markdown report with embedded screenshots and a “Next actions” checklist.
```

### Prompt for repository inspection and holistic improvements

Use this when you need an agent to inspect a codebase and recommend improvements before your next deploy:

```
Goal: Perform a holistic review of the repository and produce prioritized, diff-ready improvements.

Inputs:
- Repo URL or local path: <PASTE_REPO_URL>

Checklist & Deliverables:
1. Build/run workflow:
   • Detect package managers and scripts; verify no mixing of npm and Yarn
   • Check that the start command uses process.env.PORT/0.0.0.0 (Node) or dynamic port (Python)
   • Verify /api/health or add one if missing
2. Deployment readiness (Railway):
   • Run an 8‑step quick check: ports, health path, inter-service URLs (Railway domain variables), CORS, WebSockets, Dockerfile, logs, start command
   • Generate a one-page “Deployment Checklist” and minimal railpack.json if missing
3. Code quality & consistency:
   • Ensure TS strict mode, ESLint + Prettier; Black + Ruff for Python
   • Identify duplicated code; propose refactors and modular splits (files < 300 lines)
4. Security & config:
   • Replace hard-coded secrets with env vars; create an .env.example
   • Add a CORS allowlist for your frontend(s); avoid “*” in production
5. Testing:
   • Add or update unit/integration tests (Vitest for TS, Pytest for Python)
   • Define E2E flows for the UI (e.g., Cypress)
   • Provide coverage targets and integrate tests into CI
6. Documentation:
   • Create/update AGENTS.md with setup/build/test instructions and Railway notes
   • Ensure each major folder has a README explaining its purpose and how to run

Outputs:
- A markdown audit report (summary + details)
- A PR plan with conventional-commit-scoped commit titles
- Code blocks for all new/changed files (ready to paste)
```

These prompts reflect the issues that frequently arise during your deploy and build workflows and encapsulate the best practices we’ve discussed【426†source】【431†source】. Use them to drive consistent, efficient debugging and improvement cycles.

# Railway Deployment Master Cheat Sheet
## Common Pitfalls & Correct Solutions

---

## 🔴 **ISSUE 1: Build System Conflicts**

### **Common Error Pattern:**
```
Nixpacks build failed
ERROR: failed to exec pid1: No such file or directory
```

### **Root Cause:**
Multiple build configurations competing (Dockerfile, railway.toml, railpack.json, nixpacks.toml)

### **Correct Solution:**
```bash
# Railway Build Priority Order (highest to lowest):
# 1. Dockerfile (if exists)
# 2. railpack.json (if exists) 
# 3. railway.json/railway.toml
# 4. Nixpacks (auto-detection)

# ENFORCE RAILPACK ONLY:
rm Dockerfile railway.toml nixpacks.toml  # Remove competing configs
touch railpack.json                        # Create railpack config
```

### **Correct railpack.json Template:**
```json
{
  "version": "1",
  "metadata": {
    "name": "my-app"
  },
  "build": {
    "provider": "node",  // or "python" 
    "steps": {
      "install": {
        "commands": ["yarn install --frozen-lockfile"]
      },
      "build": {
        "commands": ["yarn build"]
      }
    }
  },
  "deploy": {
    "startCommand": "yarn start",
    "healthCheckPath": "/api/health",
    "healthCheckTimeout": 300
  }
}
```

---

## 🔴 **ISSUE 2: PORT Binding Failures**

### **Common Error Pattern:**
```
Application failed to respond
Health check failed at /api/health
```

### **Root Cause:**
Apps hardcoding ports or binding to localhost instead of 0.0.0.0

### **Correct Solution:**

#### **Node.js/TypeScript:**
```javascript
// ✅ CORRECT
const PORT = process.env.PORT || 3000;
const HOST = '0.0.0.0';  // NOT 'localhost' or '127.0.0.1'
app.listen(PORT, HOST, () => {
  console.log(`Server running on ${HOST}:${PORT}`);
});

// ❌ WRONG
app.listen(3000);  // Hardcoded port
app.listen(PORT, 'localhost');  // Wrong host
```

#### **Python:**
```python
# ✅ CORRECT
import os
port = int(os.environ.get("PORT", 5000))
app.run(host="0.0.0.0", port=port)

# ❌ WRONG  
app.run(host="127.0.0.1", port=5000)  # Wrong host and hardcoded port
```

#### **railpack.json Start Commands:**
```json
{
  "deploy": {
    // ✅ CORRECT
    "startCommand": "node server.js",  // Let app read PORT from env
    
    // ❌ WRONG
    "startCommand": "node server.js --port 3000"  // Hardcoded port
  }
}
```

---

## 🔴 **ISSUE 3: Theme/CSS Loading Issues**

### **Common Error Pattern:**
- Dark mode not persisting
- Tailwind classes not applying
- CSS loading after page render (flash of unstyled content)

### **Root Cause:**
Theme initialization happening after React renders, missing CSS imports

### **Correct Solution:**

#### **1. Pre-React Theme Application:**
```javascript
// src/main.tsx or index.tsx
// ✅ CORRECT - Apply theme BEFORE React renders
document.documentElement.className = localStorage.getItem('theme') || 'dark';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider>
      <App />
    </ThemeProvider>
  </React.StrictMode>
);
```

#### **2. Proper CSS Import Order:**
```css
/* src/index.css */
/* ✅ CORRECT ORDER */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Critical theme styles */
.dark {
  color-scheme: dark;
}

/* Your custom styles AFTER Tailwind */
```

#### **3. Vite Config for Railway:**
```javascript
// vite.config.ts
export default defineConfig({
  base: './',  // Relative paths for Railway
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    // Ensure CSS is bundled
    cssCodeSplit: false
  }
});
```

---

## 🔴 **ISSUE 4: Reference Variable Mistakes**

### **Common Error Pattern:**
```
"Install inputs must be an image or step input"
"serviceA.PORT does not resolve"
```

### **Root Cause:**
Misunderstanding Railway's reference variable system

### **Correct Solution:**

#### **❌ WRONG - Common Mistakes:**
```bash
# Cannot reference PORT of another service
BACKEND_URL=${{backend.PORT}}  

# Wrong inputs field in railpack.json install step
"install": {
  "inputs": [{"step": "setup"}],  # Install doesn't need inputs
  "commands": ["pip install -r requirements.txt"]
}
```

#### **✅ CORRECT - Proper References:**
```bash
# Reference public domain (Railway provides)
BACKEND_URL=https://${{backend.RAILWAY_PUBLIC_DOMAIN}}

# Reference private domain for internal communication
INTERNAL_API=http://${{backend.RAILWAY_PRIVATE_DOMAIN}}

# Railway automatically provides PORT - don't set manually
# Let Railway inject PORT, app reads from process.env.PORT
```

---

## 🔴 **ISSUE 5: Health Check Configuration**

### **Common Error Pattern:**
```
Health check failed: service unavailable
```

### **Correct Solution:**

#### **1. Add Health Endpoint:**
```javascript
// Express.js
app.get('/api/health', (req, res) => {
  res.status(200).json({ status: 'healthy' });
});

// Python Flask
@app.route('/api/health')
def health():
    return jsonify({'status': 'healthy'}), 200
```

#### **2. Configure in railpack.json:**
```json
{
  "deploy": {
    "healthCheckPath": "/api/health",
    "healthCheckTimeout": 300,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 3
  }
}
```

---

## 🔴 **ISSUE 6: Monorepo Service Confusion**

### **Common Error Pattern:**
```
Nixpacks unable to generate build plan
Multiple services detected
```

### **Correct Solution:**

#### **Separate railpack.json for Each Service:**
```bash
# Project structure
/
├── backend/
│   └── railpack.json  # Backend-specific config
├── frontend/
│   └── railpack.json  # Frontend-specific config
└── railpack.json      # Root config (if needed)
```

#### **Root railpack.json for Monorepo:**
```json
{
  "version": "1",
  "services": {
    "backend": {
      "root": "./backend",
      "build": {
        "provider": "python"
      }
    },
    "frontend": {
      "root": "./frontend", 
      "build": {
        "provider": "node"
      }
    }
  }
}
```

---

## 📋 **Pre-Deployment Validation Checklist**

```bash
# 1. Check for conflicting build configs
ls -la | grep -E "(Dockerfile|railway\.toml|nixpacks\.toml|railpack\.json)"

# 2. Validate railpack.json syntax
cat railpack.json | jq '.' > /dev/null && echo "✅ Valid JSON"

# 3. Verify PORT usage in code
grep -r "process.env.PORT\|PORT" . | grep -v node_modules

# 4. Check host binding
grep -r "0\.0\.0\.0\|localhost\|127\.0\.0\.1" . | grep -E "(listen|HOST|host)"

# 5. Verify health endpoint exists
grep -r "/health\|/api/health" . | grep -v node_modules

# 6. Test build locally
yarn build && PORT=3000 yarn start

# 7. Create git hook for validation
cat > .git/hooks/pre-push << 'EOF'
#!/bin/bash
if [ -f railpack.json ]; then
  jq '.' railpack.json > /dev/null || exit 1
fi
EOF
chmod +x .git/hooks/pre-push
```

---

## 🚀 **Quick Fix Commands**

```bash
# Force Railpack rebuild
railway up --force

# Clear Railway build cache
railway run --service <service-name> railway cache:clear

# Debug environment variables
railway run env | grep -E "(PORT|HOST|RAILWAY)"

# Test health endpoint
railway run curl http://localhost:$PORT/api/health
```

---

## 📝 **Add to Your Coding Assistant Rules**

```markdown
## Railway Deployment Standards

1. **Always use railpack.json** as the primary build configuration
2. **Never hardcode ports** - always use process.env.PORT
3. **Always bind to 0.0.0.0** not localhost or 127.0.0.1
4. **Apply theme before React renders** to prevent flash of unstyled content
5. **Reference domains not ports** in Railway variables (${{service.RAILWAY_PUBLIC_DOMAIN}})
6. **Include health check endpoint** at /api/health returning 200 status
7. **Remove competing build files** (Dockerfile, railway.toml) when using railpack.json
8. **Test locally with Railway environment**: railway run yarn dev
9. **Validate JSON syntax** before committing railpack.json
10. **Use inputs field only for layer references** in railpack.json, not for basic installs
```

This cheat sheet addresses the recurring issues I found across your Railway projects. Add these rules to your coding assistant configuration to prevent these issues from happening again.


Cache strategies | https://yarnpkg.com/features/caching | 
Constraints | https://yarnpkg.com/features/constraints | 
Extensibility | https://yarnpkg.com/features/extensibility | 
Install modes | https://yarnpkg.com/features/linkers | 
Package patching | https://yarnpkg.com/features/patching | 
Performances | https://yarnpkg.com/features/performances | 
Plug'n'Play | https://yarnpkg.com/features/pnp | 
Release Workflow | https://yarnpkg.com/features/release-workflow | 
Scripting | https://yarnpkg.com/features/scripting | 
Security | https://yarnpkg.com/features/security | 
Workspaces | https://yarnpkg.com/features/workspaces | 