var w=Object.defineProperty,E=(a,n,e)=>n in a?w(a,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[n]=e,B=(a,n,e)=>E(a,typeof n!="symbol"?n+"":n,e);const I=class p{constructor(){B(this,"logLevel","INFO")}static getInstance(){return p.instance||(p.instance=new p),p.instance}setLogLevel(n){this.logLevel=n}shouldLog(n){const e={DEBUG:0,INFO:1,WARN:2,ERROR:3,FATAL:4};return e[n]>=e[this.logLevel]}createLogEntry(n,e,s,t,c){return{level:n,message:e,timestamp:new Date().toISOString(),context:s,error:t,data:c}}formatLogEntry(n){const{level:e,message:s,timestamp:t,context:c,error:l}=n,o=c?`[${c}] `:"",r=l?`
Error: ${l.stack||l.message}`:"";return`[${t}] [${e}] ${o}${s}${r}`}logToConsole(n){const e=this.formatLogEntry(n);switch(n.level){case"DEBUG":console.debug(e);break;case"INFO":console.info(e);break}}debug(n,e,s){if(this.shouldLog("DEBUG")){const t=this.createLogEntry("DEBUG",n,e,void 0,s);this.logToConsole(t)}}info(n,e,s){if(this.shouldLog("INFO")){const t=this.createLogEntry("INFO",n,e,void 0,s);this.logToConsole(t)}}warn(n,e,s,t){if(this.shouldLog("WARN")){const c=this.createLogEntry("WARN",n,e,s,t);this.logToConsole(c)}}error(n,e,s,t){if(this.shouldLog("ERROR")){const c=this.createLogEntry("ERROR",n,e,s,t);this.logToConsole(c)}}fatal(n,e,s,t){if(this.shouldLog("FATAL")){const c=this.createLogEntry("FATAL",n,e,s,t);this.logToConsole(c)}}};B(I,"instance");let C=I;const S=C.getInstance();function U(a,n){try{const e={...a.parameters,timeframe:a.parameters.timeframe||"5m"};switch(a.algorithm||a.name){case"MovingAverageCrossover":case"Moving Average Crossover":return R(e,n);case"RSI":return b(e,n);case"MACD":return y(e,n);case"BollingerBands":case"Bollinger Bands":return x(e,n);case"Custom":return $();default:return S.error(`Unknown strategy algorithm: ${a.algorithm||a.name}`),{signal:null,reason:"Unknown strategy type",confidence:0}}}catch(e){return S.error("Strategy execution error:","StrategyExecutor",e instanceof Error?e:new Error(String(e))),{signal:null,reason:"Strategy execution error",confidence:0}}}function R(a,n){const e=a,{fastPeriod:s=9,slowPeriod:t=21}=e;if(n.length<t+2)return{signal:null,reason:"Insufficient data for MA calculation",confidence:0};const c=A(n,s),l=A(n,t);if(c.length<2||l.length<2)return{signal:null,reason:"Insufficient MA history for crossover evaluation",confidence:0};const o=c.at(-1),r=c.at(-2),i=l.at(-1),u=l.at(-2);if(o===void 0||r===void 0||i===void 0||u===void 0)return{signal:null,reason:"MA values unavailable for crossover evaluation",confidence:0};const d=r<=u&&o>i,f=r>=u&&o<i,v=Math.abs(o-i),h=(o+i)/2,g=Math.min(.9,v/h*10);return d?{signal:"BUY",reason:`Bullish crossover: Fast MA (${s}) crossed above Slow MA (${t})`,confidence:g}:f?{signal:"SELL",reason:`Bearish crossover: Fast MA (${s}) crossed below Slow MA (${t})`,confidence:g}:{signal:null,reason:"No crossover detected",confidence:0}}function b(a,n){const e=a,{period:s=14,overbought:t=70,oversold:c=30}=e;if(n.length<s+1)return{signal:null,reason:"Insufficient data for RSI calculation",confidence:0};const l=F(n,s);if(l.length<2)return{signal:null,reason:"Insufficient RSI history for signal evaluation",confidence:0};const o=l.at(-1),r=l.at(-2);if(o===void 0||r===void 0)return{signal:null,reason:"RSI values unavailable for evaluation",confidence:0};let i=0;if(o<c){if(i=Math.min(.9,(c-o)/c),r<o)return{signal:"BUY",reason:`RSI (${o.toFixed(2)}) turning up from oversold zone (${c})`,confidence:i}}else if(o>t&&(i=Math.min(.9,(o-t)/(100-t)),r>o))return{signal:"SELL",reason:`RSI (${o.toFixed(2)}) turning down from overbought zone (${t})`,confidence:i};return{signal:null,reason:`RSI (${o.toFixed(2)}) is in neutral zone`,confidence:0}}function y(a,n){const e=a,{fastPeriod:s=12,slowPeriod:t=26,signalPeriod:c=9}=e;if(n.length<t+c)return{signal:null,reason:"Insufficient data for MACD calculation",confidence:0};const o=N(n,s,t,c).histogram;if(o.length<2)return{signal:null,reason:"Insufficient MACD histogram history for crossover evaluation",confidence:0};const r=o.at(-1),i=o.at(-2);if(r===void 0||i===void 0)return{signal:null,reason:"MACD histogram values unavailable for evaluation",confidence:0};const u=Math.min(.9,Math.abs(r)/.5);return i<=0&&r>0?{signal:"BUY",reason:"MACD histogram turned positive (bullish crossover)",confidence:u}:i>=0&&r<0?{signal:"SELL",reason:"MACD histogram turned negative (bearish crossover)",confidence:u}:{signal:null,reason:"No MACD crossover detected",confidence:0}}function x(a,n){const e=a,{period:s=20,stdDev:t=2}=e;if(n.length<s)return{signal:null,reason:"Insufficient data for Bollinger Bands calculation",confidence:0};const c=O(n,s,t);if(n.length<2)return{signal:null,reason:"Insufficient candles for Bollinger Bands signal evaluation",confidence:0};const l=n.at(-1),o=n.at(-2);if(!l||!o)return{signal:null,reason:"Missing candles for Bollinger evaluation",confidence:0};const r=l.close,i=o.close,u=c.upper.at(-1),d=c.lower.at(-1);if(u===void 0||d===void 0)return{signal:null,reason:"Insufficient Bollinger Bands history for signal evaluation",confidence:0};let f=0;if(r<d){if(f=Math.min(.9,(d-r)/(d*.05)),i<r)return{signal:"BUY",reason:"Price bouncing up from lower Bollinger Band",confidence:f}}else if(r>u&&(f=Math.min(.9,(r-u)/(u*.05)),i>r))return{signal:"SELL",reason:"Price bouncing down from upper Bollinger Band",confidence:f};return{signal:null,reason:"Price within Bollinger Bands, no signal",confidence:0}}function $(){return{signal:null,reason:"Custom strategy not implemented",confidence:0}}function A(a,n){const e=a.map(t=>t.close),s=[];for(let t=n-1;t<e.length;t++){const c=e.slice(t-n+1,t+1).reduce((l,o)=>l+o,0);s.push(c/n)}return s}function L(a,n){const e=a.map(o=>o.close),s=[],t=2/(n+1);if(e.length<n||n<=0)return s;const l=e.slice(0,n).reduce((o,r)=>o+r,0)/n;s.push(l);for(let o=n;o<e.length;o++){const r=e[o],i=s.at(-1);r===void 0||i===void 0||s.push((r-i)*t+i)}return s}function F(a,n){const e=a.map(i=>i.close),s=[],t=[],c=[];for(let i=1;i<e.length;i++){const u=e[i],d=e[i-1];if(u===void 0||d===void 0)continue;const f=u-d;s.push(f>0?f:0),t.push(f<0?-f:0)}let l=s.slice(0,n).reduce((i,u)=>i+u,0)/n,o=t.slice(0,n).reduce((i,u)=>i+u,0)/n,r=l/(o===0?.001:o);c.push(100-100/(1+r));for(let i=n;i<s.length;i++){const u=s[i],d=t[i];u===void 0||d===void 0||(l=(l*(n-1)+u)/n,o=(o*(n-1)+d)/n,r=l/(o===0?.001:o),c.push(100-100/(1+r)))}return c}function N(a,n,e,s){const t=L(a,n),c=L(a,e),l=[],o=c.length-t.length;for(let f=0;f<t.length;f++)if(f>=0&&o>=0&&f<t.length){const v=t[f],h=f+o,g=c[h];v!==void 0&&g!==void 0&&l.push(v-g)}const r=[],i=2/(s+1);if(l.length>=s&&s>0){const v=l.slice(0,s).reduce((h,g)=>h+g,0)/s;r.push(v);for(let h=s;h<l.length;h++){const g=l[h],m=r.at(-1);g===void 0||m===void 0||r.push((g-m)*i+m)}}const u=[],d=l.length-r.length;for(let f=0;f<r.length;f++){const v=f+d,h=l[v],g=r[f];h===void 0||g===void 0||u.push(h-g)}return{macd:l,signal:r,histogram:u}}function O(a,n,e){const s=a.map(o=>o.close),t=A(a,n),c=[],l=[];if(s.length>=n&&n>0)for(let o=n-1;o<s.length;o++){const r=s.slice(o-n+1,o+1),u=r.reduce((m,M)=>m+M,0)/n,f=r.map(m=>Math.pow(m-u,2)).reduce((m,M)=>m+M,0)/n,v=Math.sqrt(f),h=o-(n-1),g=t[h];g!==void 0&&(c.push(g+v*e),l.push(g-v*e))}return{middle:t,upper:c,lower:l}}export{U as e};
//# sourceMappingURL=strategyExecutors-CW6YIKo8.js.map
