var L=Object.defineProperty;var B=(l,e,s)=>e in l?L(l,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):l[e]=s;var M=(l,e,s)=>B(l,typeof e!="symbol"?e+"":e,s);const I=["debug","info","warn","error"],f=class f{constructor(){M(this,"logs",[]);M(this,"maxLogs",1e3)}static getInstance(){return f.instance||(f.instance=new f),f.instance}createLogEntry(e,s,o){return{timestamp:new Date().toISOString(),level:e,message:s,data:o}}addLog(e){if(this.logs.push(e),this.logs.length>this.maxLogs&&(this.logs=this.logs.slice(-this.maxLogs)),I.includes(e.level)){const{timestamp:s,level:o,message:r,data:c}=e;console[o==="error"?"error":o==="warn"?"warn":"log"](`[${o.toUpperCase()}] ${s} - ${r}`,c||"")}}debug(e,s){this.addLog(this.createLogEntry("debug",e,s))}info(e,s){this.addLog(this.createLogEntry("info",e,s))}warn(e,s){this.addLog(this.createLogEntry("warn",e,s))}error(e,s){this.addLog(this.createLogEntry("error",e,s))}getLogs(e){return e?this.logs.filter(s=>s.level===e):this.logs}clearLogs(){this.logs=[]}};M(f,"instance");let v=f;const A=v.getInstance();function P(l,e){try{const s={...l.parameters,timeframe:l.parameters.timeframe||"5m"};switch(l.type){case"MovingAverageCrossover":return x(s,e);case"RSI":return C(s,e);case"MACD":return b(s,e);case"BollingerBands":return $(s,e);case"Custom":return y();default:return A.error(`Unknown strategy type: ${l.type}`),{signal:null,reason:"Unknown strategy type",confidence:0}}}catch(s){return A.error("Strategy execution error:",s),{signal:null,reason:"Strategy execution error",confidence:0}}}function x(l,e){const s=l,{fastPeriod:o=9,slowPeriod:r=21}=s;if(e.length<r+2)return{signal:null,reason:"Insufficient data for MA calculation",confidence:0};const c=w(e,o),t=w(e,r),n=c[c.length-1],a=c[c.length-2],i=t[t.length-1],u=t[t.length-2],g=a<=u&&n>i,m=a>=u&&n<i,p=Math.abs(n-i),h=(n+i)/2,d=Math.min(.9,p/h*10);return g?{signal:"BUY",reason:`Bullish crossover: Fast MA (${o}) crossed above Slow MA (${r})`,confidence:d}:m?{signal:"SELL",reason:`Bearish crossover: Fast MA (${o}) crossed below Slow MA (${r})`,confidence:d}:{signal:null,reason:"No crossover detected",confidence:0}}function C(l,e){const s=l,{period:o=14,overbought:r=70,oversold:c=30}=s;if(e.length<o+1)return{signal:null,reason:"Insufficient data for RSI calculation",confidence:0};const t=E(e,o),n=t[t.length-1],a=t[t.length-2];let i=0;if(n<c){if(i=Math.min(.9,(c-n)/c),a<n)return{signal:"BUY",reason:`RSI (${n.toFixed(2)}) turning up from oversold zone (${c})`,confidence:i}}else if(n>r&&(i=Math.min(.9,(n-r)/(100-r)),a>n))return{signal:"SELL",reason:`RSI (${n.toFixed(2)}) turning down from overbought zone (${r})`,confidence:i};return{signal:null,reason:`RSI (${n.toFixed(2)}) is in neutral zone`,confidence:0}}function b(l,e){const s=l,{fastPeriod:o=12,slowPeriod:r=26,signalPeriod:c=9}=s;if(e.length<r+c)return{signal:null,reason:"Insufficient data for MACD calculation",confidence:0};const t=R(e,o,r,c),n=t.histogram[t.histogram.length-1],a=t.histogram[t.histogram.length-2],i=Math.min(.9,Math.abs(n)/.5);return a<=0&&n>0?{signal:"BUY",reason:"MACD histogram turned positive (bullish crossover)",confidence:i}:a>=0&&n<0?{signal:"SELL",reason:"MACD histogram turned negative (bearish crossover)",confidence:i}:{signal:null,reason:"No MACD crossover detected",confidence:0}}function $(l,e){const s=l,{period:o=20,stdDev:r=2}=s;if(e.length<o)return{signal:null,reason:"Insufficient data for Bollinger Bands calculation",confidence:0};const c=U(e,o,r),t=e[e.length-1].close,n=e[e.length-2].close,a=c.upper[c.upper.length-1],i=c.lower[c.lower.length-1];let u=0;if(t<i){if(u=Math.min(.9,(i-t)/(i*.05)),n<t)return{signal:"BUY",reason:"Price bouncing up from lower Bollinger Band",confidence:u}}else if(t>a&&(u=Math.min(.9,(t-a)/(a*.05)),n>t))return{signal:"SELL",reason:"Price bouncing down from upper Bollinger Band",confidence:u};return{signal:null,reason:"Price within Bollinger Bands, no signal",confidence:0}}function y(){return{signal:null,reason:"Custom strategy not implemented",confidence:0}}function w(l,e){const s=l.map(r=>r.close),o=[];for(let r=e-1;r<s.length;r++){const c=s.slice(r-e+1,r+1).reduce((t,n)=>t+n,0);o.push(c/e)}return o}function S(l,e){const s=l.map(t=>t.close),o=[],r=2/(e+1),c=s.slice(0,e).reduce((t,n)=>t+n,0)/e;o.push(c);for(let t=e;t<s.length;t++)o.push((s[t]-o[o.length-1])*r+o[o.length-1]);return o}function E(l,e){const s=l.map(i=>i.close),o=[],r=[],c=[];for(let i=1;i<s.length;i++){const u=s[i]-s[i-1];o.push(u>0?u:0),r.push(u<0?-u:0)}let t=o.slice(0,e).reduce((i,u)=>i+u,0)/e,n=r.slice(0,e).reduce((i,u)=>i+u,0)/e,a=t/(n===0?.001:n);c.push(100-100/(1+a));for(let i=e;i<o.length;i++)t=(t*(e-1)+o[i])/e,n=(n*(e-1)+r[i])/e,a=t/(n===0?.001:n),c.push(100-100/(1+a));return c}function R(l,e,s,o){const r=S(l,e),c=S(l,s),t=[];for(let g=0;g<r.length;g++)g>=c.length-r.length&&t.push(r[g]-c[g-(c.length-r.length)]);const n=[],a=2/(o+1),i=t.slice(0,o).reduce((g,m)=>g+m,0)/o;n.push(i);for(let g=o;g<t.length;g++)n.push((t[g]-n[n.length-1])*a+n[n.length-1]);const u=[];for(let g=0;g<n.length;g++)u.push(t[g+(t.length-n.length)]-n[g]);return{macd:t,signal:n,histogram:u}}function U(l,e,s){const o=l.map(n=>n.close),r=w(l,e),c=[],t=[];for(let n=e-1;n<o.length;n++){const a=o.slice(n-e+1,n+1),u=a.reduce((h,d)=>h+d,0)/e,m=a.map(h=>Math.pow(h-u,2)).reduce((h,d)=>h+d,0)/e,p=Math.sqrt(m);c.push(r[n-(e-1)]+p*s),t.push(r[n-(e-1)]-p*s)}return{middle:r,upper:c,lower:t}}export{P as e};
//# sourceMappingURL=strategyExecutors-aBpXDD8U.js.map
